[{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"intro-to-global-forest-watch","dir":"Articles","previous_headings":"","what":"Intro to Global Forest Watch","title":"Download & Preprocessing","text":"Global Forest Watch makes available global data products produced Hansen et al (2013) examining Landsat satellite data characterize global forest extent, annual loss, gain. data annual updates provide spatially detailed information forest cover. However, challenges arise using Earth Observation (EO) assess trends forest loss. context forest conservation, spatial statistics can assist quickly identifying spatio-temporal trends forest loss without explicit need pre-existing information underlying factors driving trends. However, remains challenge distinguish loss forest cover caused intentional clearing loss forest due natural disturbances. can find following data layers GFW data set: ‘Treecover2000’: layer gives tree canopy cover year 2000, defined canopy closure vegetation taller 5m height, measured percentage ranging 0 100 percent ‘Loss’: layer gives tree cover loss study period, defined complete stand-replacement disturbance (.e., change forest non-forest state). ‘Gain’: Tree cover gain summarized period 2000–2012, defined inverse information contained ‘Loss’ layer (non-forest forest change entirely within study period) ‘Lossyear’: Year gross tree cover loss event. Tree cover loss study period, defined stand-replacement disturbance, change forest non-forest state. Encoded either 0 (loss) else value range 1–18, representing loss detected primarily year 2001–2018 conceptual challenge data set overall losses gains provided gross estimates year 2000 2018. means obtain annual maps forest losses gains retrieve annual net deforestation values. can, however, derive gross estimate forest clearance using loss year layer. , every stand-replacement disturbance associated specific year time series 2000-2018, can obtain binary forest loss maps every year. important note possibility forest gains time series accounted approach. shortcoming, however chose deliver inexpensive reliable first insights deforestation dynamics.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"download-data","dir":"Articles","previous_headings":"","what":"Download data","title":"Download & Preprocessing","text":"can download data given area interest presented download function sf-object. basename variable can specify character string prepended file names. specification dataset variable defines version GFW download. default version 1.6 tracks forest cover dynamics 2000 2018. newer version (1.7) also includes year 2019 already available. Simply change dataset variable “GFC-2019-v.1.7”. variable outdir specifies put final merged raster files, single tiles first downloaded .tmpdir directory mosaiced gdal system call. can choose keep single tiles specifying keepTmpFiles = TRUE wish keep future analysis. specific tile needed requested area interest, already found .tmpdir, going downloaded . can come handy work different projects, e.g. country. Note, CO2 dataset limited availability dataset roughly present tropics subtropics 30N 30S. can check availability . cases CO2 data requested AOI, function issue warning simply append empty CO2 raster. mean areas CO2 emissions trough forest cover clearing simply measured data source.","code":"# read in polygons of interest aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\"))  # download GFW data for the area of interest raster_files = downloadGFW(shape = aoi,                            basename = \"pkgTest\",                            dataset = \"GFC-2018-v1.6\",                            outdir = \"../data/\",                            keepTmpFiles = T,                            .tmpdir = \"../data/tmp\")  # in case the projection between aoi and the downloaded rasters is different, # we need to reproject the aoi object aoi = st_transform(aoi, crs = st_crs(raster(raster_files[1]))) # crop the rasters to the extent of the aoi rasters = stack(lapply(raster_files, function(f){   f = brick(f)   f = crop(f, aoi) })) # assigning proper names to the layers and simply plot the results names(rasters) = c(\"co2_emission\", \"lossyear\", \"treecover\") plot(rasters)"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"preprocessing","dir":"Articles","previous_headings":"","what":"Preprocessing","title":"Download & Preprocessing","text":"can use loss year layer tree cover layer year 2000 calculate binary tree cover maps modeling different forest definitions. usage developed simple interface R routine work us called prepTC(). function applies , classification binary raster applying cover threshold removing clumps raster cells smaller given threshold. routine also able apply either one tasks. Note, however, functions calculate areal statistics expect binary rasters input. Next, going explain detail thresholds applied.","code":"prep_treeCover = prepTC(inputForestMap = rasters$treecover,                         thresholdCover = 75,                         thresholdClump = 20)"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"coverage-threshold","dir":"Articles","previous_headings":"","what":"Coverage Threshold","title":"Download & Preprocessing","text":"can see tree cover map year 2000 coded percentage tree canopy coverage 0 100. Using information, able apply threshold reclassification model national forest definitions, example tree canopy larger 50% ground’s surface. loss year layer, pixels plotted grayish color. pixels value 0 meaning tree cover loss observed time series 2000 2018. redish green, pixels indicate year forest loss occurred. going use information retrieve annual forest maps conjunction tree cover layer base year 2000. However, take look effect applying threshold filtering tree cover layer first.  applied threshold tree cover 50% recoded values 0 values equal greater threshold 1. way obtained binary forest mask year 2000 corresponding forest definition 50% tree canopy soil surface.","code":"treeCover_binary = rasters$treecover treeCover_binary[rasters$treecover< 50 ] = 0 treeCover_binary[rasters$treecover>= 50] = 1 plot(treeCover_binary)"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"clump-removal","dir":"Articles","previous_headings":"","what":"Clump Removal","title":"Download & Preprocessing","text":"national agencies well international organizations might concentrate efforts definitions forest conservation areas minimum size comprehensive tree cover. account can apply clump detection. algorithm basically assigns increasing value starting 1 every comprehensive clump finds data. pixels one clump assigned value pixels adjacent pixels clump, algorithm jumps next clump assigns pixels value increased one. sample area, looks like :  pixels show greyish colour, indicating compromised one clumps, however, can observe increasing raster cell values North South minor areas. means algorithm started distribute number clumps North slowly moving downwards South every pixel associated clump. taking look frequency certain clump class occurs new data set, can apply another threshold remove clumps smaller desired value. work expected, take account cell size raster data. interpret cell size additionally need information coordinate reference system (CRS) data currently represented . can see data represented geographic coordinates, based geographic datum reference ellipsoid WGS84. means units pixels resolution needs interpreted degrees data projected planar coordinate system. now, apply threshold terms meters hectares. can also estimate desired threshold based degrees. equator, one degree East-West direction (x) equal 100km. kilometers, distance reduced closer get poles. means pixel size meters approximately 25 ~ 30 meters. Now, want filter forest areas leas 5 ha size, need translate number pixels represent clump desired size. One pixel 30m x 30m = 900m², forest area 5ha * 10,000m²/ha = 50,000m², 50,000m² / 900m² = 5.55 pixels. choose threshold minimum size 6 pixels. First, however use freq-function calculate number occurrences per clump class raster. , can filter values show occurrences lower threshold set 0.  can observe differences resulting output two rasters smaller patches forest removed right hand raster. now compare results manually applied processing results obtained calling function prepTC() beginning tutorial.","code":"treeCover_clumps = clump(treeCover_binary) plot(treeCover_clumps) st_crs(treeCover_clumps) # retrives the coordinate reference system #> Coordinate Reference System: #>   User input: WGS 84 (with axis order normalized for visualization)  #>   wkt: #> GEOGCRS[\"WGS 84 (with axis order normalized for visualization)\", #>     DATUM[\"World Geodetic System 1984\", #>         ELLIPSOID[\"WGS 84\",6378137,298.257223563, #>             LENGTHUNIT[\"metre\",1]]], #>     PRIMEM[\"Greenwich\",0, #>         ANGLEUNIT[\"degree\",0.0174532925199433]], #>     CS[ellipsoidal,2], #>         AXIS[\"geodetic longitude (Lon)\",east, #>             ORDER[1], #>             ANGLEUNIT[\"degree\",0.0174532925199433, #>                 ID[\"EPSG\",9122]]], #>         AXIS[\"geodetic latitude (Lat)\",north, #>             ORDER[2], #>             ANGLEUNIT[\"degree\",0.0174532925199433, #>                 ID[\"EPSG\",9122]]]] res(treeCover_clumps) # gives the cell size in x and y direction #> [1] 0.00025 0.00025 frequencies = data.frame(freq(treeCover_clumps)) # gets frequency per value filt_frequencies = frequencies [which(frequencies $count >= 6), ] # selects only those values with frequencies > 5 filt_frequencies  = as.vector(filt_frequencies $value) # to vector  treeCover_clean = treeCover_clumps # initiate clean raster names(treeCover_clean) = \"clumps.removed\" treeCover_clean[!treeCover_clean %in% filt_frequencies] = 0 treeCover_clean[treeCover_clean != 0] = 1 plot(stack(treeCover_binary, treeCover_clean)) names(prep_treeCover) = \"cover75.clumps20\" names(treeCover_clean) = \"cover50.clumps5\" plot(stack(treeCover_clean, prep_treeCover))"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/GFW.html","id":"yearly-forest-mask","dir":"Articles","previous_headings":"","what":"Yearly Forest Mask","title":"Download & Preprocessing","text":"next step retrieve pseudo-yearly forest cover maps loss year layer. step, , create R routine eases process significantly. can applied directly input forest cover map base year loss year layer. Note, years vector indicates years present loss year layer excluding base years specified input. workflow look like, manually? use first raster layer obtained applying threshold pre-processing base layer year 2000. recode value 0, represents forest loss entire time series NA. , loop remaining year values 1 18 reclassify pixels base tree cover layer 0 equal lower current year value loss year layer.  processes retrieved yearly binary forest mask. Note stage applied threshold minimal mapping unit base year 2000. cases want apply threshold remaining years additional working step needed.  hard tell exact differences raster layers. Therefore quick pixel count pixels representing forest estimation forest area.","code":"yearlyForestMask = getTM(inputForestMap = treeCover_clean,                          inputLossMap = rasters$lossyear,                          years = 2001:2018) # set value of 0 to NA rasters$lossyear[rasters$lossyear == 0] = NA # mask lossyear layer to our binary mask so onyl valid pixels remain rasters$lossyear = mask(rasters$lossyear, treeCover_clean) # vector of values found in loss year, 1 : 2001, 2: 2002 ... 18: 2018 unis = 1:18  # initiate the yearlyForestMask raster stack with the binary layer for 2000 yearlyForestMask = treeCover_clean  # loop trough the year values and set them to 1 in case they are # lower or equal to the current value (Forest Loss) or 0 when # they are greater (no forest loss during that year) for (u in unis){   tmpLS = rasters$lossyear   tmpLS[tmpLS <= u] = 1   tmpLS[tmpLS > u] = 0      # set the pixels in the binary forest mask to 0 which    # showed forest loss in the current year of years before   tmpTC = treeCover_clean   tmpTC[tmpLS == 1] = 0   # add the resulting layer to the raster stack   yearlyForestMask = addLayer(yearlyForestMask, tmpTC) } # renaming and simple plot names(yearlyForestMask) = paste(\"y\", 2000:2018) plot(yearlyForestMask[[11:19]]) for (l in 1:nlayers(yearlyForestMask)){   yearlyForestMask[[l]] = prepTC(yearlyForestMask[[l]], thresholdClump = 5) }  plot(yearlyForestMask[[1:8]]) as.data.frame(yearlyForestMask) %>%   summarise_all(sum, na.rm=TRUE) %>%   gather(\"year\",\"value\") %>%   mutate(year = str_sub(year, -4, -1)) %>%   ggplot(aes(x= year, y=value))+   geom_point(stat=\"identity\")+   ylab(\"Number of forest pixels\")+   xlab(\"Year of Observation\")+   theme_minimal()"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/area_stats.html","id":"forest-area-statistics","dir":"Articles","previous_headings":"","what":"Forest Area Statistics","title":"Area Statistics","text":"vignette Global Forest Watch explained pre-process Hansen dataset model various forest definition requirements national international organizations. also explained can obtain pseudo-yearly forest masks combination tree cover dataset year 2000 loss year layer. section, taking look obtain areal statistics regions interest pre-processed data. Evidently, workflows explained therefore also valid binary forest mask obtained sources. taking consideration three different parameters section, course yearly forest cover within region interest, yearly loss forest cover well CO2 emissions caused forest cover loss. last parameter, using additional dataset, requires explanation using . dataset describes emission -ground woody biomass loss tropics (Zarin et al. 2016) reflects estimated tons carbon dioxide emissions atmosphere result -ground biomass loss. Estimates based collocation -ground live woody biomass density values year 2000 (Baccini et al. 2012) annual tree cover loss data 2001 2018 (Hansen et al. 2013). responsible use dataset crucial note, -ground carbon considered “committed” emissions atmosphere upon clearing. Emissions “gross” rather “net” estimates, meaning information fate land clearing, associated carbon value, incorporated.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/area_stats.html","id":"calculation-of-areal-statistics","dir":"Articles","previous_headings":"","what":"Calculation of areal statistics","title":"Area Statistics","text":"First, read necessary datasets need present calculation. Additionally tree cover loss layer need dataset representing CO2 emissions woody biomass well regions interest want derive aggregated values. take quick look polygons interest spatially distributed study area.  Now, small test dataset, purpose demonstrate functionality routines developed . general, units interest arbitrary polygons distributed globe, representing valuable ecosystems protected areas, intervention regions international donor organizations well complete countries states. really depends needs project, units calculate areal statistics . routines used optimized parallel computing rather large machines process lot data less time. However, can also used smaller machines like laptops office computers, especially regions interest might small number size. start , applying pre-processing routine tree cover dataset remove clumps desired threshold retrieve yearly binary forest masks.","code":"# read in example data from package directory treeCover = raster(system.file(\"extdata\", \"pkgTest_treecover2000.tif\", package = \"mapme.forest\")) names(treeCover) = \"tree.cover\" lossYear = raster(system.file(\"extdata\", \"pkgTest_lossyear.tif\", package = \"mapme.forest\")) names(lossYear) = \"loss.year\" co2Layer = raster(system.file(\"extdata\", \"pkgTest_co2_emission.tif\", package = \"mapme.forest\")) names(co2Layer) = \"co2.emiss\" roi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) ## Reading layer `aoi_polys' from data source  ##   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 8 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 ## Geodetic CRS:  WGS 84 # create simple plot plot(treeCover) plot(roi, add =TRUE, col=NA) # clump removal and threshold application to source data from the year 2000 treeCover_binary = prepTC(treeCover,                           thresholdClump = 10,                           thresholdCover = 50)  # creation of yearly maps based on binary raster and loss year layer treeCover_yearly = getTM(treeCover_binary,                          lossYear, 2000:2018)  # applying minimal mapping unit for the yearly layers treeCover_yearly = stack(lapply(1:nlayers(treeCover_yearly), function(l){   treeCover_yearly[[l]] = prepTC(treeCover_yearly[[l]], thresholdClump = 10) })) # stack all layers to get time series 2000 to 2018 names(treeCover_yearly) = paste(\"y\", 2000:2018, sep = \"\")"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/area_stats.html","id":"tree-cover-area","dir":"Articles","previous_headings":"","what":"Tree Cover Area","title":"Area Statistics","text":", present standard approach call functions. first might calculate yearly forest area within polygon. Note, area calculated differently projected raster datasets raster data geographic coordinates. former uses units projection precisly calculate area within pixel, latter estimates area pixel based geographic position using raster::area. Projecting data suitable projection deliver accurate results might good idea project data applying function. , compare effect projecting raster data local coordinate reference system (CRS). choose UTM use code calculate UTM zone central point raster.  , see projected raster well shapefile UTM. either one shows different projection , function area calculation error stop execution. apply AreaCalc routine input datasets, one time specifying latlon=TRUE time latlon=FALSE. parameters let function know area estimated based geographic position globe using raster::area()area raster data handed function projected coordinated system. former gives area estimation km², multiply value 100 change unit ha. Since choose UTM projection example, map unit meters. need divide values 10000 order get ha. Finally, calculate difference two matrices summarize differences values plot simple boxplot. can see mean difference area estimates -0.3892222 indicating non-projected raster dataset delivers area estimates average 0.33 ha lower compared projected approach. estimate difference percent reveals average difference -0.01%. Whether margin error negligible depends application.","code":"# calculate the corresponding utm zone centroid = suppressWarnings(st_centroid(st_as_sfc(st_bbox(treeCover_yearly)))) zone = floor((st_coordinates(centroid)[1] + 180) / 6) + 1 utm = paste0(\"+proj=utm +zone=\", zone,\" +ellps=WGS84 +datum=WGS84 +units=m +no_defs\")  # reproject the raster data set proj_TC_yearly = projectRaster(treeCover_yearly, crs = utm, method = \"ngb\") # reproject the regions of interest proj_roi = sf::st_transform(roi, utm)  ncores = 2 if(\"Windows\" %in% Sys.info()['sysname']) ncores = 1 # area calculation for unprojected raster result_latlon = AreaCalc(treeCover_yearly,                          studysite = roi[2,],                          latlon=TRUE,                          polyName = \"id\",                          ncores = ncores,                          years = 2000:2018) # area calculation fo projected raster result_proj = AreaCalc(proj_TC_yearly,                        studysite = proj_roi[2,],                        latlon=FALSE,                        polyName = \"id\",                        ncores = ncores,                        years = 2000:2018) # rescale area values to ha for unprojected results area_latlon = st_drop_geometry(result_latlon) %>%   select(-id) %>%   mutate_all(function(x) x * 100) # rescale to ha  # rescalue area values to ha for projected results area_proj = st_drop_geometry(result_proj) %>%   select(-id) %>%    mutate_all(function(x) x / 10000) # rescale to ha   # calculate difference summaries diff = area_latlon - area_proj summ = summary(unlist(diff)) summ ##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  ## -0.7219 -0.5539 -0.5537 -0.3892 -0.2614  0.1677 boxplot(unlist(diff)) mean((1-(unlist(area_latlon) / unlist(area_proj)))*100) ## [1] 0.1599743"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/area_stats.html","id":"some-notes-on-parallel-processing","dir":"Articles","previous_headings":"","what":"Some notes on parallel processing","title":"Area Statistics","text":"Note function calls included argument called ncores determines number cores used parallel processing. wish use parallel processing can choose value 1 make function work sequential mode. might different scenarios, may want disable parallel computing. obvious one machine necessary computing power parallel processing though modern shipped laptops least equipped two four processors. Another scenario might working high number small regions interest want efficiently use local memory. using functions well functions areal statistics, polygon underlying raster datasets processed simultaneously independently. leads copying lot input data might cause troubles smaller machines. case , might make sense call functions parallel version lapply. used way, less data simultaneously copied memory, can still parallelize workflow. approach might less advisable, however, regions interest large, example countries states. use cases refer reader article Big Data Analyisis. Also note used sf::st_drop_geometry function obtain areal data. AreaCalc function alike return roi object, class sf data columns amended areal statistics. important, addition areal statistics, returned objects take geometry information us. might useful applications, therefore can drop geometry using sf functionality.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/area_stats.html","id":"forest-loss-area-co2-emissions","dir":"Articles","previous_headings":"","what":"Forest Loss Area & CO2 Emissions","title":"Area Statistics","text":"calculation forest loss area per year much alike area calculation. However, next binary forest masks, also add loss year layer. Note, obvious reasons forest loss also calculated forest area information within roi dataframe. Despite also include function calculate loss support wider range use cases. estimation CO2 emissions corresponding forest cover loss, use similiar function call seen addtionally provide CO2 layer. can now bind together results obtained order get one sf-object areal statistics found. , use dplyr functionality data-handling can applied sf-objects well data set hand, can start investigate forest cover dynamics polygons. use simple ggplot visualization. Since data currently presented wide format, means row represents one polygon, need transfer long format handing data ggplot.","code":"# calculation of forest loss area loss_area = LossCalc(inputForestMap = treeCover_yearly,                      inputLossMap = lossYear,                      studysite = result_latlon,                      latlon = TRUE,                      polyName = \"id\",                      ncores = ncores,                      years = 2000:2018) # calculation of co2 emissions co2_emission = CO2Calc(inputForestMap = treeCover_yearly,                        inputLossMap = lossYear,                        inputCO2Map = co2Layer,                        studysite = result_latlon,                        polyName = \"id\",                        ncores = ncores,                        years = 2000:2018) # binding all areal statistics together results = st_drop_geometry(result_latlon) %>%   left_join(st_drop_geometry(loss_area)) %>%   left_join(st_drop_geometry(co2_emission)) # simple plot of yearly tree cover plt = results %>%   gather(\"type\", \"area\", -id) %>%   separate(type, into = c(\"var\",\"year\"), \"_\") %>%   mutate(year = as.factor(as.numeric(year)),          var = as.factor(var),          area = as.numeric(area),          id = as.factor(id)) %>%   ggplot(aes(x = year, y = area)) +   facet_grid(rows = vars(var), scales = \"free_y\") +   geom_line(aes(group = id, color = \"red\")) +   geom_point(aes(color = \"red\")) +    theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))  ggplotly(plt)"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/frag_stats.html","id":"fragmentation-indicators","dir":"Articles","previous_headings":"","what":"Fragmentation Indicators","title":"Fragmentation Statistics","text":"Fragmentation statistics area calculated based package SDMTools based FRAGSTATS (McGarigal et al. 2012). implemented support following indicators: Available Fragmentation Statistics","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/frag_stats.html","id":"calculation-of-fragmentation-indicators","dir":"Articles","previous_headings":"","what":"Calculation of Fragmentation Indicators","title":"Fragmentation Statistics","text":"indicators calculated given polygon based underlying distribution pixels binary forest mask. reason, can easily use functionality explained previous vignettes calculate fragmentation statistics. First, let us read data calculate yearly binary forest cover maps.  case read [vignette areal statistics](vignette(“area_stats”) already familiar code. , please read continuing read fragmentation statistics. plot can already see area interest characterized heavy tree cover losses last two decades. able catch dynamic fragmentation statistics well, since forest area becomes smaller patchy time possibly altering landscape statistics well. calculate fragmentation statistics developed routine called FragStatsCalc(). can either calculate selected indicators table specifying character vector called FragStats simply calculate indicators specifying FragStats = \"\" conveniently also default setting. code calculated available fragmentation indicators eight polygons. resulting frag_statistics object basically sf-object called aoi dataframe amended 792 variables. printed structure variables matching pattern patch.density . can see, first three parameters associated year. parameters trend values Dif representing difference first last observation (2000 2018 present case), Sig representing significance Slope slope sens-slope-trend calculation (click learn algorithm behind sens slope). parameters, values specific year shown. numeric vectors length eight, representing one polygons aoi object.","code":"# reading data treeCover = raster(system.file(\"extdata\", \"pkgTest_treecover2000.tif\", package = \"mapme.forest\")) names(treeCover) = \"tree.cover\" lossYear = raster(system.file(\"extdata\", \"pkgTest_lossyear.tif\", package = \"mapme.forest\")) names(lossYear) = \"loss.year\"  # applying preprocessing treeCover_binary = prepTC(treeCover,                           thresholdClump = 10,                           thresholdCover = 50) treeCover_yearly = getTM(treeCover_binary,                          lossYear,                          2000:2018)  # applying minimal mapping unit for the yearly layers treeCover_yearly = stack(lapply(1:nlayers(treeCover_yearly), function(l){   treeCover_yearly[[l]] = prepTC(treeCover_yearly[[l]], thresholdClump = 10) }))  names(treeCover_yearly) = paste(\"y\", 2000:2018, sep = \"\")  # plotting only first and last layer plot(treeCover_yearly[[c(1,19)]]) # read in polygons to extract fragmentation statistics for aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) ## Reading layer `aoi_polys' from data source  ##   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  ##   using driver `GPKG' ## Simple feature collection with 8 features and 1 field ## Geometry type: POLYGON ## Dimension:     XY ## Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 ## Geodetic CRS:  WGS 84 ncores = 2 if(\"Windows\" %in% Sys.info()['sysname']) ncores = 1  frag_statistics = FragStatsCalc(inputRasterFiles = treeCover_yearly,                                  latlon = T,                                  polyName = \"id\",                                  studysite = aoi,                                  FragStats = \"all\",                                  ncores = ncores)  cat(\"Number of rows: \", nrow(frag_statistics)) ## Number of rows:  8 cat(\"Number of columns: \",ncol(frag_statistics)) ## Number of columns:  794 str(frag_statistics[grep(\"patch.density\", names(frag_statistics))]) ## Classes 'sf' and 'data.frame':   8 obs. of  23 variables: ##  $ patch.density_Dif  : num  -1.26e-06 -2.13e-07 -8.42e-07 2.27e-07 -1.73e-07 ... ##  $ patch.density_Sig  : num  0.55941 0.035533 0.007614 0.009046 0.000214 ... ##  $ patch.density_Slope: num  0.00 9.67e-08 1.68e-07 4.53e-08 3.03e-07 ... ##  $ patch.density_y2000: num  1.26e-06 8.51e-07 1.68e-06 1.59e-06 5.20e-07 ... ##  $ patch.density_y2001: num  2.51e-06 8.51e-07 2.74e-06 4.30e-06 5.20e-07 ... ##  $ patch.density_y2002: num  2.51e-06 8.51e-07 2.74e-06 4.30e-06 6.94e-07 ... ##  $ patch.density_y2003: num  2.51e-06 8.51e-07 2.74e-06 4.30e-06 6.94e-07 ... ##  $ patch.density_y2004: num  2.51e-06 8.51e-07 2.95e-06 4.30e-06 6.94e-07 ... ##  $ patch.density_y2005: num  2.51e-06 8.51e-07 3.16e-06 4.53e-06 1.73e-06 ... ##  $ patch.density_y2006: num  2.51e-06 8.51e-07 3.58e-06 4.53e-06 1.73e-06 ... ##  $ patch.density_y2007: num  5.02e-06 8.51e-07 3.58e-06 4.53e-06 1.73e-06 ... ##  $ patch.density_y2008: num  8.79e-06 1.06e-06 4.00e-06 4.53e-06 1.73e-06 ... ##  $ patch.density_y2009: num  8.79e-06 1.06e-06 4.00e-06 4.53e-06 2.08e-06 ... ##  $ patch.density_y2010: num  7.54e-06 3.19e-06 4.21e-06 4.53e-06 2.95e-06 ... ##  $ patch.density_y2011: num  7.54e-06 4.04e-06 4.84e-06 4.30e-06 3.64e-06 ... ##  $ patch.density_y2012: num  7.54e-06 4.47e-06 4.63e-06 6.34e-06 4.33e-06 ... ##  $ patch.density_y2013: num  7.54e-06 4.89e-06 4.84e-06 6.57e-06 4.85e-06 ... ##  $ patch.density_y2014: num  7.54e-06 4.68e-06 5.05e-06 7.48e-06 4.85e-06 ... ##  $ patch.density_y2015: num  2.51e-06 4.25e-06 4.21e-06 6.12e-06 6.07e-06 ... ##  $ patch.density_y2016: num  0.00 3.19e-06 3.37e-06 5.89e-06 5.38e-06 ... ##  $ patch.density_y2017: num  0.00 1.91e-06 3.37e-06 4.08e-06 2.77e-06 ... ##  $ patch.density_y2018: num  0.00 6.38e-07 8.42e-07 1.81e-06 3.47e-07 ... ##  $ geometry           :sfc_POLYGON of length 8; first list element: List of 1 ##   ..$ : num [1:5, 1:2] 107 107 107 107 107 ... ##   ..- attr(*, \"class\")= chr [1:3] \"XY\" \"POLYGON\" \"sfg\" ##  - attr(*, \"sf_column\")= chr \"geometry\" ##  - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... ##   ..- attr(*, \"names\")= chr [1:22] \"patch.density_Dif\" \"patch.density_Sig\" \"patch.density_Slope\" \"patch.density_y2000\" ..."},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/frag_stats.html","id":"non-spatial-visualization","dir":"Articles","previous_headings":"","what":"Non-Spatial Visualization","title":"Fragmentation Statistics","text":"Now let us plot dynamic selected indicators time 2000 2018. choose number patches, average patch area total edge length visualization. discuss trend statistics , drop target data frame. handing data ggplot2 need reshape data wide representation long representation (see thorough discussion reshaping R dataframes). can observe plot , average patch area significantly reduced years. indicator landscape consisted large patches became patchy smaller average areas. also observed second parameter, total number patches. year 2015 , number patches increases almost polygons 10 20 even 30. However, number patches decreases last years might point towards complete disappearance forest patches towards end observation period. total length edges shows similar pattern steep increase first years even steeper decrease towards end time series. , indicates high number forest patches completely disappearing. demonstrated calculation interpretation fragmentation parameters polygons basis. parameters important certain question, however, remains discussed specific project context.","code":"# select target variables target_variables = st_drop_geometry(frag_statistics[grep(paste(\"id\", \"n.patches\", \"total.edge\", \"mean.patch.area\", sep=\"|\"), names(frag_statistics))]) # drop unneeded variables target_variables = target_variables[,-grep(paste(\"Dif\", \"Sig\", \"Slope\", sep=\"|\"), names(target_variables))] # reshape and plot with dplyr syntax and pipe operator plt = target_variables %>%    gather(\"year\", \"value\", -id) %>%   separate(year, into = c(\"var\",\"year\"), \"_\") %>%   mutate(year = as.factor(str_sub(year, -4, -1)),          id = as.factor(id),          var = as.factor(var)) %>%   ggplot(aes(x=year, y = value)) +   geom_line(aes(color = id, group = id)) +   facet_wrap(~var, scales = \"free_y\") +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1)) ggplotly(plt)"},{"path":"https://mapme-initiative.github.io/mapme.forest/articles/frag_stats.html","id":"spatial-visualization","dir":"Articles","previous_headings":"","what":"Spatial Visualization","title":"Fragmentation Statistics","text":"might already guessed, data obtain calculation hardly suitable representation map. course visualize parameters using cholorphlet map-style like : However, high number variables spatial information variables explicit map representation like . reason, developed additional workflow allows display fragmentation statistics raster. course, come free associated several disadvantages simplifications going discuss now. idea behind visualization raster treat different zones raster polygons retrieve fragmentation statistics. align theses zones ordered fashion actually create new raster coarser resolution original one. values new raster actually represent going corresponding cells original raster. However, values vary based decision align zones big , meaning resolution choose new raster. Let us start creating regular spaced grid study area. specify resolution new raster set might good idea project data first metric CRS. based Vietnam, UTM zone 48N seems reasonable. shows us, projecting raster dataset resolution 26.7 meters x direction resolution 27.7 meters y direction. Now, need grid `s cell sizes aggregates original raster certain factor. Currently one pixel comprises read 740 m². Let us say, want aggregate raster factor 200, means target cells cover area 14.79 ha. use number calculate many cells original resolution needed get one target cell, simply put square root aggregation factor. , can calculate many columns rows get simply aggregated original cells coarser resolution. finally create matrix multiplying number cells original resolution within one unit target resolution number columns rows desired target resolution. can see target matrix slightly bigger original raster. used round() ceiling() function obtain even numbers needed create matrix. now fill created matrix nested loop, assigning values cells comprise one cell target resolution. need simply variable n_cells representing square root aggregation factor. Now got matrix resembles original raster assigning common value cells comprise one cell target resolutions. zones going calculate fragmentation indicators . remains one small problem, however, target matrix currently slightly larger original raster. account , simply delete rows columns many evenely sights fo matrix. However, means reduce size zones edges matrix compared inner zones. makes outer zones incomparable inner ones. practice, means always calculate indicators raster slightly bigger area interest crop end. Now, got matrix exactly resembles original raster values matrix indicate zones target resolution. need now, transform information sf-object able calculate fragmentation statistics know . work, first transform matrix raster. addition raster package use functions stars sf, work efficiently polygonizing raster values. now calculate fragmentation statistics polygons just way saw . command executed time markdown rendered try speed computation time calculating one indicator one layers treeCover_proj object.  Now, left crop raster smaller extent order get rid cells edge meaningful values.","code":"tmap_mode(\"view\")  tm_basemap(\"OpenStreetMap\") +   tm_shape(frag_statistics) +   tm_polygons(\"total.core.area_y2000\") utm = \"+proj=utm +zone=48 +ellps=WGS84 +datum=WGS84 +units=m +no_defs\" treeCover_proj = projectRaster(treeCover_yearly, crs = CRS(utm), method = \"ngb\") res(treeCover_proj) ## [1] 26.7 27.7 agg_factor = 200 n_cells = round(sqrt(agg_factor)) ncols = ceiling(ncol(treeCover_proj) / n_cells) nrows = ceiling(nrow(treeCover_proj) / n_cells) m = matrix(nrow = n_cells * nrows, ncol = n_cells * ncols)  cat(\"Dimension of our target matrix is: \", dim(m)) ## Dimension of our target matrix is:  476 658 cat(\"Dimension of our original raster is: \", dim(treeCover_proj)) ## Dimension of our original raster is:  469 658 19 for (i in 1:ncols){   for (j in 1:nrows){     m[(n_cells*j - n_cells + 1) : ((n_cells*(j+1) - n_cells)) , (n_cells*i - n_cells + 1) : (n_cells*(i+1) - n_cells)] = 1 * i * j   } } diff_nrow =  nrow(m) - nrow(treeCover_proj) diff_ncol =  ncol(m) - ncol(treeCover_proj) m = m[(((diff_nrow / 2) ) +1): (nrow(m) - (diff_nrow / 2)) , ((diff_ncol / 2) +1): (ncol(m) - (diff_ncol / 2)) ] cat(\"Dimension of our target matrix is: \", dim(m)) ## Dimension of our target matrix is:  469 658 cat(\"Dimension of our original raster is: \", dim(treeCover_proj)) ## Dimension of our original raster is:  469 658 19 grid = raster(m) crs(grid) = crs(treeCover_proj) extent(grid) = extent(treeCover_proj) grid_stars = stars::st_as_stars(grid) polys = st_as_sf(grid_stars[1], as_points = FALSE, merge = T) polys$id = 1:nrow(polys) plot(polys[\"id\"]) grid_fragstats = FragStatsCalc(inputRasterFiles = treeCover_proj[[1]],                                latlon = F,                                polyName = \"id\",                                studysite = polys,                                FragStats = \"patch.density\",                                ncores = ncores) results = st_drop_geometry(grid_fragstats) result_raster = raster(matrix(data = results$patch.density_V1, ncol = ncols, nrow = nrows)) result_raster[] = NA crs(result_raster) = crs(treeCover_proj) extent(result_raster) = extent(treeCover_proj) result_raster = setValues(result_raster, as.matrix(results$patch.density_V1)) plot(result_raster) bbox = st_as_sfc(st_bbox(result_raster)) bbox_buffer = st_buffer(bbox, dist = -500) cat(\"Uncropped raster with buffered extent\") ## Uncropped raster with buffered extent plot(result_raster) plot(bbox_buffer, add = T) results_cropped = crop(result_raster, st_as_sf(bbox_buffer)) cat(\"Cropped raster\") ## Cropped raster plot(results_cropped)"},{"path":"https://mapme-initiative.github.io/mapme.forest/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Darius Görgen. Maintainer, author. MAPME-Initiative. Copyright holder, funder.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Görgen D (2022). mapme.forest: Package Support Project Evaluation Planning Forest Sector. R package version 1.0, https://mapme-initiative.github.io/mapme.forest.","code":"@Manual{,   title = {mapme.forest: Package to Support Project Evaluation and Planning in the Forest Sector},   author = {Darius Görgen},   year = {2022},   note = {R package version 1.0},   url = {https://mapme-initiative.github.io/mapme.forest}, }"},{"path":[]},{"path":"https://mapme-initiative.github.io/mapme.forest/index.html","id":"important-warning","dir":"","previous_headings":"","what":"IMPORTANT WARNING","title":"An R package for processing GlobalForestWatch (GFW) datasets for deforestation monitoring","text":"use CO2 emission layer analysis currently discouraged. Several routines need adapted since usage new data set Harris et al (2021) (see https://www.nature.com/articles/s41558-020-00976-6). Check https://github.com/mapme-initiative/mapme.forest/issues/7 receive information issue solved.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/index.html","id":"about","dir":"","previous_headings":"","what":"About","title":"An R package for processing GlobalForestWatch (GFW) datasets for deforestation monitoring","text":"mapme.forest package helps understanding recent past deforestation dynamics around world. Next calculating areal statistics amount deforestation given space, tool provides ability calculate high number common fragmentation statistics given landscape.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/index.html","id":"tutorial","dir":"","previous_headings":"","what":"Tutorial","title":"An R package for processing GlobalForestWatch (GFW) datasets for deforestation monitoring","text":"tutorial usage mapme.forest package can found . Please visit page order get know API mapme.forest.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/index.html","id":"installation-instructions-under-linux","dir":"","previous_headings":"","what":"Installation instructions under Linux","title":"An R package for processing GlobalForestWatch (GFW) datasets for deforestation monitoring","text":"mapme.forest package can installed using remotes package entering following command: remotes::install_github(\"mapme-initiative/mapme.forest\"). Additionally, ship package Dockerfile can used run packages dependencies container. cding repository, building running image simple : docker build -t mapmeForest:latest . docker run -d -p 8787:8787 -e USER=myuser -e PASSWORD=mypassword gans-deforestation","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/index.html","id":"installation-instructions-under-windows","dir":"","previous_headings":"","what":"Installation instructions under Windows","title":"An R package for processing GlobalForestWatch (GFW) datasets for deforestation monitoring","text":"installation instruction assume going use R Studio IDE. need software pre-installed software able install forestIndicator package. download install R >= 3.5.x https://cran.rstudio.com/ download install R Studio https://rstudio.com/products/rstudio/download/#download download install Rtools https://cran.r-project.org/bin/windows/Rtools make Rtools available PATH variable install remotes packages ‘install.packages(“remotes”)’ install mapme.forest following command: remotes::install_github(\"mapme-initiative/mapme.forest\") close R Studio afterwards Now package sucessfully installed, however, necessarily 100% ready use . Since function use gdal system calls additionally need valid gdal installation machine. go https://trac.osgeo.org/osgeo4w/ download osgeo4w.exe run chose advanced installation follow instructions. follwing assume choose standard installation path. chose custom installation path adjust next inputs accordingly. asked software install open Commandline_Utilities branch chose following: gdal python3-* entries Libs branch chose following package: libs python3-gdal installation completed add environment variables Windows know look programs. open: System Controls -> System Safety -> System -> Advanced Settings -> Environment Variables -> System Variables edit PATH variable add three entries: C:\\OSGeo4W64\\bin C:\\OSGeo4W64\\apps\\Python37 C:\\OSGeo4W64\\apps\\Python37\\Scripts add four new variables following scheme: Name: GDAL_DATA Value: C:\\OSGeo4W64\\share\\gdal Name: PROJ_LIB Value: C:\\OSGeo4W64\\share\\proj PYTHONHOME Value: C:\\OSGeo4W64\\apps\\Python37 PYTHONPATH Value: C:\\OSGeo4W64\\apps\\Python37\\python.exe open command line enter: gdal_calc.py getting information use script ready go note setup outlined might preffered setup. course can use different setups, e.g. using virtual anaconda environments. However, fairly advanced setups outline . important take-away message four going use different setup gdal_calc.py well usual gdal command line tools need available executable.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":null,"dir":"Reference","previous_headings":"","what":"Area of forest change — AreaCalc","title":"Area of forest change — AreaCalc","text":"Calculates changes forest area based rasterObject forest   mask SpatialPolygonsDataFrame containing areas interest.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area of forest change — AreaCalc","text":"","code":"AreaCalc(   inputForestMap = NULL,   studysite = NULL,   latlon = NULL,   polyName = NULL,   ncores = 1,   saveCSV = FALSE,   years = 2001:2018 )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area of forest change — AreaCalc","text":"inputForestMap RasterLayer object forest cover represented binary (e.g 0 represents forest; 1 represents forest). layer expected represent one year years object consecutive order. studysite object type sf given number polygons defining areas interest. Forest area statistics calculated features studysite object. latlon logical: Indicates whether inputForestMap object based geographic coordinate system projected planar coordinate system. former case, area approximated raster::area. polyName charachter length 1. Indicates column data frame studysite object uniquely identify features interest. function fail unique identification polygons ncores number cores use, .e. many child processes run simultaneously. saveCSV Default FALSE. can specify directory local machine results area saved .csv format. features identified column specified polyName. years vector type numeric indicating years represented pixels. GFW data default 2001 2018.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area of forest change — AreaCalc","text":"studysite object data frame appended columnwise  every single entry years object representing total area  forest given layer inputForestMap object.  latlon=TRUE returned area km², otherwise  squared unit input projection (commonly meters).","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Area of forest change — AreaCalc","text":"function relies heavily parallization, indicating   importance , high number CPUs large enough RAM.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Area of forest change — AreaCalc","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/AreaCalc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area of forest change — AreaCalc","text":"","code":"library(sf) #> Linking to GEOS 3.8.0, GDAL 3.0.4, PROJ 6.3.1; sf_use_s2() is TRUE library(raster) #> Loading required package: sp library(mapme.forest)  aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) #> Reading layer `aoi_polys' from data source  #>   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 8 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 #> Geodetic CRS:  WGS 84 yearlyRaster = stack(system.file(\"extdata\", \"pkgTest_yearlyCover.tif\",                                  package = \"mapme.forest\")) result = AreaCalc(inputForestMap = yearlyRaster,                   studysite = aoi[1,],                   latlon = TRUE,                   polyName = \"id\",                   ncores = 1,                   saveCSV = FALSE,                   years = 2000:2018) str(result) #> Classes ‘sf’ and 'data.frame':\t1 obs. of  21 variables: #>  $ id       : int 1 #>  $ area_2000: num 0.722 #>  $ area_2001: num 0.722 #>  $ area_2002: num 0.722 #>  $ area_2003: num 0.722 #>  $ area_2004: num 0.721 #>  $ area_2005: num 0.491 #>  $ area_2006: num 0.135 #>  $ area_2007: num 0.135 #>  $ area_2008: num 0.129 #>  $ area_2009: num 0.128 #>  $ area_2010: num 0.128 #>  $ area_2011: num 0.128 #>  $ area_2012: num 0.0685 #>  $ area_2013: num 0.0371 #>  $ area_2014: num 0.0275 #>  $ area_2015: num 0.0264 #>  $ area_2016: num 0.0257 #>  $ area_2017: num 0.0257 #>  $ area_2018: num 0.0257 #>  $ geom     :sfc_POLYGON of length 1; first list element: List of 1 #>   ..$ : num [1:5, 1:2] 107 107 107 107 107 ... #>   ..- attr(*, \"class\")= chr [1:3] \"XY\" \"POLYGON\" \"sfg\" #>  - attr(*, \"sf_column\")= chr \"geom\" #>  - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... #>   ..- attr(*, \"names\")= chr [1:20] \"id\" \"area_2000\" \"area_2001\" \"area_2002\" ..."},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":null,"dir":"Reference","previous_headings":"","what":"CO2 Emissions by Forest Loss — CO2Calc","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"Calculation CO2 emissions resulting forest loss time series. uses information occurence forest loss amount CO2 present biomass calculate sum CO2 emissions yearly basis.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"","code":"CO2Calc(   inputForestMap = NULL,   inputLossMap = NULL,   inputCO2Map = NULL,   studysite = NULL,   ncores = 1,   polyName = NULL,   saveCSV = FALSE,   years = 2001:2018 )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"inputForestMap RasterLayer object forest cover represented binary (e.g 0 represents forest; 1 represents forest). layer expected represent one year years object consecutive order. inputLossMap RasterLayer object values indicating year tree cover lost. annual area tree cover lost calculated based values found data set. inputCO2Map RasterLayer object values indicating amount CO2 equivalent present biomass given pixel. annual sum CO2 emissions per feature studysite object calculated based data set. studysite object type sf given number polygons defining areas interest. Forest area statistics calculated features studysite object. ncores number cores use, .e. many child processes run simultaneously. polyName charachter length 1. Indicates column data frame studysite object uniquely identify features interest. function fail unique identification polygons saveCSV Default FALSE. can specify directory local machine results area saved .csv format. features identified column specified polyName. years vector type numeric indicating years represented pixels. GFW data default 2001 2018.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"studysite object attribute table ammended   results calculation. Additionally, csv file containing polyName  attribute well results calculation can saved disk.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"function relies heavily parallization, indicating   importance , high number CPUs large enough RAM.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/CO2Calc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"CO2 Emissions by Forest Loss — CO2Calc","text":"","code":"library(sf) library(raster) library(mapme.forest)  aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) #> Reading layer `aoi_polys' from data source  #>   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 8 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 #> Geodetic CRS:  WGS 84 yearlyRaster = stack(system.file(\"extdata\", \"pkgTest_yearlyCover.tif\",                                  package = \"mapme.forest\")) lossRaster = raster(system.file(\"extdata\", \"pkgTest_lossyear.tif\",                                 package = \"mapme.forest\")) co2Raster = raster(system.file(\"extdata\", \"pkgTest_co2_emission.tif\",                                package = \"mapme.forest\"))  result = CO2Calc(inputForestMap = yearlyRaster,                  inputLossMap = lossRaster,                  inputCO2Map = co2Raster,                  studysite = aoi[1,],                  polyName = \"id\",                  ncores = 1,                  saveCSV = FALSE,                  years = 2000:2018) #> Warning: IMPORTANT WARNING: The use of the CO2 emission layer during analysis is currently discouraged. #>            Several routines need to be adapted since the usage of a new data set by Harris et al (2021) (see https://www.nature.com/articles/s41558-020-00976-6) #>            Check out https://github.com/mapme-initiative/mapme.forest/issues/7 to recieve information if the issue has been solved. str(result) #> Classes ‘sf’ and 'data.frame':\t1 obs. of  21 variables: #>  $ id      : int 1 #>  $ co2_2000: num 0 #>  $ co2_2001: num 0 #>  $ co2_2002: num 0 #>  $ co2_2003: num 0 #>  $ co2_2004: num 0 #>  $ co2_2005: num 33 #>  $ co2_2006: num 9450 #>  $ co2_2007: num 14526 #>  $ co2_2008: num 0 #>  $ co2_2009: num 253 #>  $ co2_2010: num 7.26 #>  $ co2_2011: num 0 #>  $ co2_2012: num 0 #>  $ co2_2013: num 2202 #>  $ co2_2014: num 1088 #>  $ co2_2015: num 368 #>  $ co2_2016: num 42.6 #>  $ co2_2017: num 27 #>  $ co2_2018: num 0 #>  $ geom    :sfc_POLYGON of length 1; first list element: List of 1 #>   ..$ : num [1:5, 1:2] 107 107 107 107 107 ... #>   ..- attr(*, \"class\")= chr [1:3] \"XY\" \"POLYGON\" \"sfg\" #>  - attr(*, \"sf_column\")= chr \"geom\" #>  - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... #>   ..- attr(*, \"names\")= chr [1:20] \"id\" \"co2_2000\" \"co2_2001\" \"co2_2002\" ..."},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/ClassStat2.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates landscape class statistics based on the R package ","title":"Calculates landscape class statistics based on the R package ","text":"ClassStat2 calculates user defined set landscape fragmentation indices patch types identified  matrix data raster class ’asc’ (SDMTools & adehabitat packages), ’RasterLayer’ (raster package)  ’SpatialGrid-DataFrame’ (sp package). actually used helper function  within FragStatsCalc function.  heavily based SDMTools:ClassStat function.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/ClassStat2.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates landscape class statistics based on the R package ","text":"","code":"ClassStat2(   inputLayer,   cellsize = 30,   bkgd = NA,   latlon = FALSE,   na.rm = TRUE,   FragStats = \"all\" )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/ClassStat2.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates landscape class statistics based on the R package ","text":"inputLayer matrix data patches identified classes (unique integer values) e.g., binary lanscape species distribution vegetation map. Matrix can raster class ’asc’ (adehabitat package), ’RasterLayer’ (raster package) `SpatialGridDataFrame`` (sp package). cellsize cell size (meters) single value representing width/height cell edges (assuming square cells). bkgd background value statistics calculated. latlon logical: Indicates whether inputForestMap object based geographic coordinate system projected planar coordinate system. former case, area approximated raster::area. na.rm Logical NA values removed calculating statistics. Defaults TRUE. FragStats Character vector list forest fragmentation parameetrs calculated.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/ClassStat2.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates landscape class statistics based on the R package ","text":"raster stack two layers per class 'classValue' object.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/ClassStat2.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculates landscape class statistics based on the R package ","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"Calculates user defined set landscape fragmentation indices patch types identified raster*Object.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"","code":"FragStatsCalc(   inputRasterFiles = NULL,   latlon = NULL,   polyName = NULL,   studysite = NULL,   FragStats = \"all\",   ncores = 1,   saveCSV = FALSE )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"inputRasterFiles raster-Object. Fragmentation statistics area calculated seperatly every layer. latlon logical: Indicates whether inputForestMap object based geographic coordinate system projected planar coordinate system. former case, area approximated raster::area. polyName charachter length 1. Indicates column data frame studysite object uniquely identify features interest. function fail unique identification polygons studysite object type sf given number polygons defining areas interest. Forest area statistics calculated features studysite object. FragStats Character vector forest fragmentation parameters calculated. Currently available statistics : n.patches number patches particular patch type class total.area sum areas (m2) patches corresponding patch type prop.landscape proportion total lanscape represented class patch.density numbers patches corresponding patch type divided total landscape area total.edge total edge length particular patch type edge.density edge length per unit area basis facilitates comparison among landscapes varying size mean.patch.area average area patches mean.frac.dim.index mean fractal dimension index lanscape.division.index based cumulative patch area distribution interpreted probability two randomly chosen pixels landscape situated patch patch.cohesion.index measures physical connectedness corresponding patch type landscape.shape.index standardized measure total edge edge density adjusts size landscape largest.patch.index largest patch index quantifies percentage total landscape area comprised largest patch sd.patch.areastandard deviation patch areas min.patch.area minimum patch area total patch areas max.patch.area maximum patch area total patch areas perimeter.area.frac.dim perimeter-area fractal dimension equals 2 divided slope regression line obtained regressing logarithm patch area (m2) logarithm patch perimeter (m) mean.perim.area.ratio mean ratio patch perimeter. perimeter-area ratio equal ratio patch perimeter (m) area (m2) sd.perim.area.ratio standard deviation ratio patch perimeter max.perim.area.ratio maximum perimeter area ratio mean.shape.index mean shape index sd.shape.index standard deviation shape index min.shape.index minimum shape index max.shape.index maximum shape index sd.frac.dim.index standard deviation fractal dimension index min.frac.dim.index minimum fractal dimension index max.frac.dim.index maximum fractal dimension index total.core.areathe sum core areas patches (m2) prop.landscape.core proportional landscape core mean.patch.core.area mean patch core area sd.patch.core.area standard deviation patch core area min.patch.core.area minimum patch core area max.patch.core.area maximum patch core area prop.like.adjacencies calculated adjacency matrix, shows frequency different pairs patch types (including like adjacencies patch type) appear side--side map (measures degree aggregation patch types) aggregation.index computed simply area-weighted mean class aggregation index, class weighted proportional area landscape izesplitting.index based cumulative patch area distribution interpreted effective mesh number, number patches constant patch size landscape subdivided S patches, S value splitting index effective.mesh.size equals 1 divided total landscape area (m2) multiplied sum patch area (m2) squared, summed across patches landscape ncores number cores use, .e. many child processes run simultaneously. saveCSV Default FALSE. can specify directory local machine results area saved .csv format. features identified column specified polyName.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"sf-object dataframe ammended specified   fragmentation statistics one column every layer   inputRasterFiles representing observation years. Additionally trend   statistics difference first last observation   automatically calculated every single parameter based trend:sens.slope.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/FragStatsCalc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculates a user defined set of landscape fragmentation indices for patch\ntypes identified in a raster*Object. — FragStatsCalc","text":"","code":"library(sf) library(raster) library(mapme.forest)  aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) #> Reading layer `aoi_polys' from data source  #>   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 8 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 #> Geodetic CRS:  WGS 84 yearlyRaster = stack(system.file(\"extdata\", \"pkgTest_yearlyCover.tif\",                                  package = \"mapme.forest\")) names(yearlyRaster) = paste(\"y_\", as.character(2000:2018))  result = FragStatsCalc(inputRasterFiles = yearlyRaster,                        studysite = aoi[1,],                        FragStats = c(\"n.patches\", \"total.area\",                                      \"prop.landscape\", \"patch.density\"),                        latlon = TRUE,                        polyName = \"id\",                        ncores = 1,                        saveCSV = FALSE) str(result) #> Classes ‘sf’ and 'data.frame':\t1 obs. of  90 variables: #>  $ id                    : int 1 #>  $ n.patches_Dif         : num 15 #>  $ n.patches_Sig         : num 0.019 #>  $ n.patches_Slope       : num 0.938 #>  $ n.patches_y_.2000     : num 1 #>  $ n.patches_y_.2001     : num 1 #>  $ n.patches_y_.2002     : num 1 #>  $ n.patches_y_.2003     : num 1 #>  $ n.patches_y_.2004     : num 1 #>  $ n.patches_y_.2005     : num 5 #>  $ n.patches_y_.2006     : num 16 #>  $ n.patches_y_.2007     : num 16 #>  $ n.patches_y_.2008     : num 19 #>  $ n.patches_y_.2009     : num 20 #>  $ n.patches_y_.2010     : num 20 #>  $ n.patches_y_.2011     : num 20 #>  $ n.patches_y_.2012     : num 15 #>  $ n.patches_y_.2013     : num 17 #>  $ n.patches_y_.2014     : num 16 #>  $ n.patches_y_.2015     : num 15 #>  $ n.patches_y_.2016     : num 16 #>  $ n.patches_y_.2017     : num 16 #>  $ n.patches_y_.2018     : num 16 #>  $ patch.density_Dif     : num 1.88e-05 #>  $ patch.density_Sig     : num 0.019 #>  $ patch.density_Slope   : num 1.18e-06 #>  $ patch.density_y_.2000 : num 1.26e-06 #>  $ patch.density_y_.2001 : num 1.26e-06 #>  $ patch.density_y_.2002 : num 1.26e-06 #>  $ patch.density_y_.2003 : num 1.26e-06 #>  $ patch.density_y_.2004 : num 1.26e-06 #>  $ patch.density_y_.2005 : num 6.28e-06 #>  $ patch.density_y_.2006 : num 2.01e-05 #>  $ patch.density_y_.2007 : num 2.01e-05 #>  $ patch.density_y_.2008 : num 2.39e-05 #>  $ patch.density_y_.2009 : num 2.51e-05 #>  $ patch.density_y_.2010 : num 2.51e-05 #>  $ patch.density_y_.2011 : num 2.51e-05 #>  $ patch.density_y_.2012 : num 1.88e-05 #>  $ patch.density_y_.2013 : num 2.14e-05 #>  $ patch.density_y_.2014 : num 2.01e-05 #>  $ patch.density_y_.2015 : num 1.88e-05 #>  $ patch.density_y_.2016 : num 2.01e-05 #>  $ patch.density_y_.2017 : num 2.01e-05 #>  $ patch.density_y_.2018 : num 2.01e-05 #>  $ prop.landscape_Dif    : num -0.942 #>  $ prop.landscape_Sig    : num 2.84e-08 #>  $ prop.landscape_Slope  : num -0.0513 #>  $ prop.landscape_y_.2000: num 0.991 #>  $ prop.landscape_y_.2001: num 0.991 #>  $ prop.landscape_y_.2002: num 0.991 #>  $ prop.landscape_y_.2003: num 0.991 #>  $ prop.landscape_y_.2004: num 0.99 #>  $ prop.landscape_y_.2005: num 0.699 #>  $ prop.landscape_y_.2006: num 0.247 #>  $ prop.landscape_y_.2007: num 0.247 #>  $ prop.landscape_y_.2008: num 0.213 #>  $ prop.landscape_y_.2009: num 0.207 #>  $ prop.landscape_y_.2010: num 0.207 #>  $ prop.landscape_y_.2011: num 0.207 #>  $ prop.landscape_y_.2012: num 0.127 #>  $ prop.landscape_y_.2013: num 0.0671 #>  $ prop.landscape_y_.2014: num 0.0531 #>  $ prop.landscape_y_.2015: num 0.0494 #>  $ prop.landscape_y_.2016: num 0.0485 #>  $ prop.landscape_y_.2017: num 0.0485 #>  $ prop.landscape_y_.2018: num 0.0485 #>  $ total.area_Dif        : num -750111 #>  $ total.area_Sig        : num 2.84e-08 #>  $ total.area_Slope      : num -40807 #>  $ total.area_y_.2000    : num 788692 #>  $ total.area_y_.2001    : num 788692 #>  $ total.area_y_.2002    : num 788692 #>  $ total.area_y_.2003    : num 788692 #>  $ total.area_y_.2004    : num 787950 #>  $ total.area_y_.2005    : num 556462 #>  $ total.area_y_.2006    : num 196616 #>  $ total.area_y_.2007    : num 196616 #>  $ total.area_y_.2008    : num 169906 #>  $ total.area_y_.2009    : num 164712 #>  $ total.area_y_.2010    : num 164712 #>  $ total.area_y_.2011    : num 164712 #>  $ total.area_y_.2012    : num 100905 #>  $ total.area_y_.2013    : num 53420 #>  $ total.area_y_.2014    : num 42291 #>  $ total.area_y_.2015    : num 39323 #>  $ total.area_y_.2016    : num 38581 #>  $ total.area_y_.2017    : num 38581 #>  $ total.area_y_.2018    : num 38581 #>  $ geometry              :sfc_POLYGON of length 1; first list element: List of 1 #>   ..$ : num [1:5, 1:2] 107 107 107 107 107 ... #>   ..- attr(*, \"class\")= chr [1:3] \"XY\" \"POLYGON\" \"sfg\" #>  - attr(*, \"sf_column\")= chr \"geometry\" #>  - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... #>   ..- attr(*, \"names\")= chr [1:89] \"id\" \"n.patches_Dif\" \"n.patches_Sig\" \"n.patches_Slope\" ..."},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":null,"dir":"Reference","previous_headings":"","what":"Area of Forest Loss — LossCalc","title":"Area of Forest Loss — LossCalc","text":"Calculation area forest loss occured tree cover time series. uses information occurence forest loss forest mask focus analysis pixles lost occured. area summed every polygon specified studysite object.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Area of Forest Loss — LossCalc","text":"","code":"LossCalc(   inputForestMap = NULL,   inputLossMap = NULL,   studysite = NULL,   latlon = NULL,   polyName = NULL,   ncores = 1,   saveCSV = FALSE,   years = 2001:2018 )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Area of Forest Loss — LossCalc","text":"inputForestMap RasterLayer object forest cover represented binary (e.g 0 represents forest; 1 represents forest). layer expected represent one year years object consecutive order. inputLossMap RasterLayer object values indicating year tree cover lost. annual area tree cover lost calculated based values found data set. studysite object type sf given number polygons defining areas interest. Forest area statistics calculated features studysite object. latlon logical: Indicates whether inputForestMap object based geographic coordinate system projected planar coordinate system. former case, area approximated raster::area. polyName charachter length 1. Indicates column data frame studysite object uniquely identify features interest. function fail unique identification polygons ncores number cores use, .e. many child processes run simultaneously. saveCSV Default FALSE. can specify directory local machine results area saved .csv format. features identified column specified polyName. years vector type numeric indicating years represented pixels. GFW data default 2001 2018.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Area of Forest Loss — LossCalc","text":"studysite object attribute table ammended   results calculation. Additionally, csv file containing polyName  attribute well results calculation can saved disk.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Area of Forest Loss — LossCalc","text":"function relies heavily parallization, indicating   importance , high number CPUs large enough RAM.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Area of Forest Loss — LossCalc","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/LossCalc.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Area of Forest Loss — LossCalc","text":"","code":"library(sf) library(raster) library(mapme.forest)  aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\")) #> Reading layer `aoi_polys' from data source  #>   `/home/runner/work/_temp/Library/mapme.forest/extdata/aoi_polys.gpkg'  #>   using driver `GPKG' #> Simple feature collection with 8 features and 1 field #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 107.1291 ymin: 16.59741 xmax: 107.2502 ymax: 16.6916 #> Geodetic CRS:  WGS 84 yearlyRaster = stack(system.file(\"extdata\", \"pkgTest_yearlyCover.tif\",                                   package = \"mapme.forest\")) lossYear = raster(system.file(\"extdata\", \"pkgTest_lossyear.tif\",                               package = \"mapme.forest\"))  result = LossCalc(inputForestMap = yearlyRaster,                  inputLossMap = lossYear,                  studysite = aoi[1,],                  latlon = TRUE,                  polyName = \"id\",                  ncores = 1,                  saveCSV = FALSE,                  years = 2000:2018) str(result) #> Classes ‘sf’ and 'data.frame':\t1 obs. of  21 variables: #>  $ id       : int 1 #>  $ loss_2000: num 0.033 #>  $ loss_2001: num 0 #>  $ loss_2002: num 0 #>  $ loss_2003: num 0 #>  $ loss_2004: num 0 #>  $ loss_2005: num 0.000737 #>  $ loss_2006: num 0.23 #>  $ loss_2007: num 0.356 #>  $ loss_2008: num 0 #>  $ loss_2009: num 0.00637 #>  $ loss_2010: num 0.000206 #>  $ loss_2011: num 0 #>  $ loss_2012: num 0 #>  $ loss_2013: num 0.0598 #>  $ loss_2014: num 0.0314 #>  $ loss_2015: num 0.00959 #>  $ loss_2016: num 0.00109 #>  $ loss_2017: num 0.000737 #>  $ loss_2018: num 0 #>  $ geom     :sfc_POLYGON of length 1; first list element: List of 1 #>   ..$ : num [1:5, 1:2] 107 107 107 107 107 ... #>   ..- attr(*, \"class\")= chr [1:3] \"XY\" \"POLYGON\" \"sfg\" #>  - attr(*, \"sf_column\")= chr \"geom\" #>  - attr(*, \"agr\")= Factor w/ 3 levels \"constant\",\"aggregate\",..: NA NA NA NA NA NA NA NA NA NA ... #>   ..- attr(*, \"names\")= chr [1:20] \"id\" \"loss_2000\" \"loss_2001\" \"loss_2002\" ..."},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/aggregation.index.html","id":null,"dir":"Reference","previous_headings":"","what":"Aggregation index — aggregation.index","title":"Aggregation index — aggregation.index","text":"Helper function calculation aggregation index ClassStat2.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/aggregation.index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aggregation index — aggregation.index","text":"","code":"aggregation.index(a, g)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/aggregation.index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aggregation index — aggregation.index","text":"g G","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/aggregation.index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aggregation index — aggregation.index","text":"Aggregation index percent.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/aggregation.index.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Aggregation index — aggregation.index","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/area_stats_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Forest area calculation single mode (Helper Function) — area_stats_seq","title":"Forest area calculation single mode (Helper Function) — area_stats_seq","text":"Forest area calculation single mode (Helper Function)","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/area_stats_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forest area calculation single mode (Helper Function) — area_stats_seq","text":"","code":"area_stats_seq(studysite, inputForestMap, latlon)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/area_stats_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Forest area calculation single mode (Helper Function) — area_stats_seq","text":"studysite sf object inputForestMap raster object latlon Logical indicating raster unprojected ","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/area_stats_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Forest area calculation single mode (Helper Function) — area_stats_seq","text":"dataframe estimated areas","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/area_stats_seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Forest area calculation single mode (Helper Function) — area_stats_seq","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/calcFragStats_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper function to calculate Fragstats for a single polygon in sequential mode — calcFragStats_seq","title":"Helper function to calculate Fragstats for a single polygon in sequential mode — calcFragStats_seq","text":"Helper function calculate Fragstats single polygon sequential mode","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/calcFragStats_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper function to calculate Fragstats for a single polygon in sequential mode — calcFragStats_seq","text":"","code":"calcFragStats_seq(studysite, inputRasterFiles, FragStats, latlon)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/calcFragStats_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper function to calculate Fragstats for a single polygon in sequential mode — calcFragStats_seq","text":"studysite one-row sf-object inputRasterFiles Raster*-Object. FragStats charachter vector.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/calcFragStats_seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Helper function to calculate Fragstats for a single polygon in sequential mode — calcFragStats_seq","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/co2_calc_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","title":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","text":"CO2 emission calculation single mode (Helper Function)","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/co2_calc_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","text":"","code":"co2_calc_seq(inputForestMap, inputLossMap, inputCO2Map, studysite, unis)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/co2_calc_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","text":"inputForestMap raster object inputLossMap raster layer object inputCO2Map raster layer object studysite sf object unis numeric vector indicating yearly cell values","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/co2_calc_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","text":"data.frame object Yearly sums co2 emissions tree cover loss","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/co2_calc_seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"CO2 emission calculation single mode (Helper Function) — co2_calc_seq","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/coverratio.html","id":null,"dir":"Reference","previous_headings":"","what":"Helper Function to calculate cover ratio — coverratio","title":"Helper Function to calculate cover ratio — coverratio","text":"function used inside area calculation functions evaluate ratio given raster covered polygon. Can used indicator cropping raster ca improve calculation time.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/coverratio.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Helper Function to calculate cover ratio — coverratio","text":"","code":"coverratio(r, p)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/coverratio.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Helper Function to calculate cover ratio — coverratio","text":"r raster object p sf object","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/coverratio.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Helper Function to calculate cover ratio — coverratio","text":"cover ratio percent","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/coverratio.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Helper Function to calculate cover ratio — coverratio","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/createGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Creates a grid of squared polygons that fully cover the spatial extent of the study area. Study area is defined by the\nRaster Layers (e.g. the Hansen data sets) thar are used as inout to calculate the forest fragmentation statistics. — createGrid","title":"Creates a grid of squared polygons that fully cover the spatial extent of the study area. Study area is defined by the\nRaster Layers (e.g. the Hansen data sets) thar are used as inout to calculate the forest fragmentation statistics. — createGrid","text":"Creates grid squared polygons fully cover spatial extent study area. Study area defined Raster Layers (e.g. Hansen data sets) thar used inout calculate forest fragmentation statistics.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/createGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Creates a grid of squared polygons that fully cover the spatial extent of the study area. Study area is defined by the\nRaster Layers (e.g. the Hansen data sets) thar are used as inout to calculate the forest fragmentation statistics. — createGrid","text":"","code":"createGrid(rasters = NULL, spacing = 500)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/createGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Creates a grid of squared polygons that fully cover the spatial extent of the study area. Study area is defined by the\nRaster Layers (e.g. the Hansen data sets) thar are used as inout to calculate the forest fragmentation statistics. — createGrid","text":"rasters raster stack forest map rasters. spacing numeric vector defining spacing grids meters, e.g. \"500\" create grids size 500m * 500m. \"500\" default","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/createGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Creates a grid of squared polygons that fully cover the spatial extent of the study area. Study area is defined by the\nRaster Layers (e.g. the Hansen data sets) thar are used as inout to calculate the forest fragmentation statistics. — createGrid","text":"raster stack two layers per class 'classValue' object.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":null,"dir":"Reference","previous_headings":"","what":"Download GFW and CO2-Emission data — downloadGFW","title":"Download GFW and CO2-Emission data — downloadGFW","text":"function downloads necessary Global Forest Watch CO2 Emission  data given shapefile. shapefile transformed bounding  box, projected central UTM Zone buffer applied. default  buffer size 5000 meteres, can changes user. uses  gdal system calls speed process. raw files default  deleted, also can kept disk. Note, CO2 emission data  available roughly 30N 30S function fail  input shapfiles extent plus buffer extending beyond limits.  function relies heavily code published https://github.com/azvoleff/gfcanalysis.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Download GFW and CO2-Emission data — downloadGFW","text":"","code":"downloadGFW(   shape,   dataset = \"GFC-2018-v1.6\",   basename = \"Hansen_1.6\",   outdir = \".\",   keepTmpFiles = F,   .tmpdir = tempfile(tmpdir = tempdir()) )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Download GFW and CO2-Emission data — downloadGFW","text":"shape sfObject determining extent get GFW data. dataset charachter specifiying version GFW data extract. Defaults version 1.6 2018. newer version can downloaded specify dataset = \"GFW-2019-v1.7\". basename charachter added resulting file names. outdir charachter local directory final outputs. existing created without message. Defaults current working directory. keepTmpFiles logical indicating raw tiles kept tmpdir directory. defaults FALSE, usually makes sense. However, apply number analysis different extents might overlaps, useful keep downloaded files machine. function download necessary data alread present tmpdir. .tmpdir charachter indicating directory download raw tiles . defaults random directory name actual R temporary directory. want keep single values, e.g. aoi spans multiple tiles, can specify custom directory.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Download GFW and CO2-Emission data — downloadGFW","text":"vector type charachter files matching  basename pattern outdir directory.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"note","dir":"Reference","previous_headings":"","what":"Note","title":"Download GFW and CO2-Emission data — downloadGFW","text":"function depends available gdal binaries system. Make sure   available environment variables machine use docker image instead.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Download GFW and CO2-Emission data — downloadGFW","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/downloadGFW.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Download GFW and CO2-Emission data — downloadGFW","text":"","code":"if (FALSE) { aoi = st_read(system.file(\"extdata\", \"aoi_polys.gpkg\", package = \"mapme.forest\"))  raster_files = downloadGFW(shape = aoi,                             basename = \"pkgTest\",                             outdir = \"./data/\",                             keepTmpFiles = T,                             .tmpdir = \"./data/tmp\")  # resulting rasters are not automatically cropped to the extent of aoi rasters = stack(lapply(raster_files, function(f){ f = brick(f) f = crop(f, aoi) })) }"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsDir.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Sens Slope Direction — funTrendsDir","title":"Calculate Sens Slope Direction — funTrendsDir","text":"function calculates sens slope direction 95  cases 75","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsDir.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Sens Slope Direction — funTrendsDir","text":"","code":"funTrendsDir(y)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsDir.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Sens Slope Direction — funTrendsDir","text":"y numeric vector calculate sens slope.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsDir.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Sens Slope Direction — funTrendsDir","text":"direction sens slope.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsDir.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Sens Slope Direction — funTrendsDir","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsSig.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate Sens Slope Trend Significance — funTrendsSig","title":"Calculate Sens Slope Trend Significance — funTrendsSig","text":"function calculates sens slope significance 95  cases 75  returned.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsSig.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate Sens Slope Trend Significance — funTrendsSig","text":"","code":"funTrendsSig(y)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsSig.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate Sens Slope Trend Significance — funTrendsSig","text":"y numeric vector calculate sens slope.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsSig.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate Sens Slope Trend Significance — funTrendsSig","text":"p-value sens slope.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/funTrendsSig.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Calculate Sens Slope Trend Significance — funTrendsSig","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":null,"dir":"Reference","previous_headings":"","what":"Get yearly binary tree cover maps — getTM","title":"Get yearly binary tree cover maps — getTM","text":"function calculates yearly tree cover maps based starting year layer binary forest mask form loss year layer indicates pixels subject forest loss given year,","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get yearly binary tree cover maps — getTM","text":"","code":"getTM(inputForestMap, inputLossMap, years = 2000:2018)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get yearly binary tree cover maps — getTM","text":"inputForestMap RasterLayer binary mask forest cover (0 representing forest; 1 representing forest) starting year. inputLossMap RasterLayer cell values represent year forest loss occured time series represented years object. years numeric vector indicating years represented values inputLossMap object. 0 expected indicate loss , value 1 corresponds first value years, value 2 second, .","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get yearly binary tree cover maps — getTM","text":"binary RasterStack number layers equal length(years).  value 0 represents forest cover, value 1 represents forest cover.  cell values indicating forest loss inputLossMap object given year  consectuivley set 0. result yearly binary classification forest cover.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Get yearly binary tree cover maps — getTM","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/getTM.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get yearly binary tree cover maps — getTM","text":"","code":"library(raster) library(mapme.forest)  binaryCover = raster(system.file(\"extdata\", \"pkgTest_binaryCover.tif\",                                  package = \"mapme.forest\")) lossYear = raster(system.file(\"extdata\", \"pkgTest_lossyear.tif\",                               package = \"mapme.forest\")) yearlyMaps = getTM(inputForestMap = binaryCover,                    inputLossMap = lossYear,                    years = 2001:2018) yearlyMaps #> class      : RasterStack  #> dimensions : 453, 643, 291279, 18  (nrow, ncol, ncell, nlayers) #> resolution : 0.00025, 0.00025  (x, y) #> extent     : 107.119, 107.2798, 16.58075, 16.694  (xmin, xmax, ymin, ymax) #> crs        : +proj=longlat +datum=WGS84 +no_defs  #> names      : y2001, y2002, y2003, y2004, y2005, y2006, y2007, y2008, y2009, y2010, y2011, y2012, y2013, y2014, y2015, ...  #> min values :     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0,     0, ...  #> max values :     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,     1, ...  #>"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/loss_calc_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Loss area calculation single mode (Helper Function) — loss_calc_seq","title":"Loss area calculation single mode (Helper Function) — loss_calc_seq","text":"Loss area calculation single mode (Helper Function)","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/loss_calc_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loss area calculation single mode (Helper Function) — loss_calc_seq","text":"","code":"loss_calc_seq(inputForestMap, inputLossMap, studysite, years, unis, latlon)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/loss_calc_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loss area calculation single mode (Helper Function) — loss_calc_seq","text":"inputForestMap raster stack inputLossMap raster layer studysite sf object single polygon years Numeric vector indicating years unis Numeric vector indicating yearly cell values latlon Logical indicating raster projected unprojected","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/loss_calc_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loss area calculation single mode (Helper Function) — loss_calc_seq","text":"data.frame yearly values forest cover loss.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/loss_calc_seq.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Loss area calculation single mode (Helper Function) — loss_calc_seq","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/makeGFWGrid.html","id":null,"dir":"Reference","previous_headings":"","what":"Create the GFW tile grid — makeGFWGrid","title":"Create the GFW tile grid — makeGFWGrid","text":"function used downloadGFW create grid representing GFW tiles.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/makeGFWGrid.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create the GFW tile grid — makeGFWGrid","text":"","code":"makeGFWGrid(mnx, mxx, dx, mny, mxy, dy, proj = NULL)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/makeGFWGrid.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create the GFW tile grid — makeGFWGrid","text":"mnx Minimum x coordinate mxx Maximum x coordinate dx x resolution mny Minimum y coordinated mxy Maximum y coordinated dy y resolution proj projection EPSG code","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/makeGFWGrid.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create the GFW tile grid — makeGFWGrid","text":"grid.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":null,"dir":"Reference","previous_headings":"","what":"Pre-Processing of tree cover layers — prepTC","title":"Pre-Processing of tree cover layers — prepTC","text":"Calculates binary tree cover mask baseline year.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Pre-Processing of tree cover layers — prepTC","text":"","code":"prepTC(inputForestMap, thresholdCover = NULL, thresholdClump = NULL)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Pre-Processing of tree cover layers — prepTC","text":"inputForestMap RasterLayer representing forest cover. primary use-case function tree cover expected values range [0,100] representing percentage used user wants obtain binary tree cover map. thresholdCover numeric vector length one range [0,100]. used definition criterium forest areas datasets like Hansen (2013), pixel's values indicates percentage coverage trees. pixel threshold get value 0, pixel get value 1. thresholdClump numeric length one indicating number pixels classified clump. number pixels smaller threshold classified NA.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Pre-Processing of tree cover layers — prepTC","text":"RasterLayer object binary values thresholdCover   specified raster cell clumps removed case thresholdClump   specified. Either one parameters can specified .","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Pre-Processing of tree cover layers — prepTC","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/prepTC.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Pre-Processing of tree cover layers — prepTC","text":"","code":"library(raster) library(mapme.forest)  treeCover = raster(system.file(\"extdata\", \"pkgTest_treecover2000.tif\",                                package = \"mapme.forest\")) binaryCover = prepTC(inputForestMap = treeCover,                              thresholdCover = 75,                              thresholdClump = 25) binaryCover #> class      : RasterLayer  #> dimensions : 453, 643, 291279  (nrow, ncol, ncell) #> resolution : 0.00025, 0.00025  (x, y) #> extent     : 107.119, 107.2798, 16.58075, 16.694  (xmin, xmax, ymin, ymax) #> crs        : +proj=longlat +datum=WGS84 +no_defs  #> source     : memory #> names      : pkgTest_treecover2000  #> values     : 0, 1  (min, max) #>"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/shape.index.html","id":null,"dir":"Reference","previous_headings":"","what":"Shape index — shape.index","title":"Shape index — shape.index","text":"Helper function calculation shape ClassStat2.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/shape.index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Shape index — shape.index","text":"","code":"shape.index(a, p)"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/shape.index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Shape index — shape.index","text":"p P","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/shape.index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Shape index — shape.index","text":"Shape index value","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/shape.index.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Shape index — shape.index","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/statsGRASS.html","id":null,"dir":"Reference","previous_headings":"","what":"Translation pipeline using GRASS — statsGRASS","title":"Translation pipeline using GRASS — statsGRASS","text":"Translation pipeline using GRASS","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/statsGRASS.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Translation pipeline using GRASS — statsGRASS","text":"","code":"statsGRASS(   grass,   addon_base,   areas,   tree_cover,   tree_loss,   tree_co2,   idcol,   thresholdClump,   thresholdCover,   years,   outdir = NULL,   saveRaster,   hideoutput = FALSE,   .tmpdir = tempdir() )"},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/statsGRASS.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Translation pipeline using GRASS — statsGRASS","text":"grass character vector pointing directory GRASS binaries installed. addon_base character vector pointing directory GRASS add-binaries installed. order work, (r.area)[https://grass.osgeo.org/grass78/manuals/addons/r.area.html] add-needs installed. See ()[https://grass.osgeo.org/download/addons/] learn install GRASS add-ons. areas sf object polygons representing areas interest preprocess individual rasters. tree_cover character vector pointing raster file representing tree cover percentage entire study domain. tree_loss character vector pointing raster file representing year tree cover loss entire study domain. tree_co2 character vector pointing raster file representing co2 emissions tree cover loss entire study domain. idcol character vector identifying column name uniquely identifies polygons areas object. Values  used name output rasters. thresholdClump numeric value identifying number pixels smallest clumps. raster cell clumps smaller specified threshold removed. thresholdCover numeric value identifying smallest cover percentage considered forest. raster cell values threshold removed years numeric vector specifying years calculate annual forest mask starting 2001. (e.g. years = c(2001:2010)). outdir character pointing directory output files written . files name specified values idcol present, calculation skipped without warning. saveRaster Logical indicating raster saved disk hideoutput Logical indicating grass output printed console. .tmpdir character string pointing directory intermediate GRASS files written . Defaults output tempdir(). Note, write access directory, otherwise function fail.","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/reference/statsGRASS.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Translation pipeline using GRASS — statsGRASS","text":"Darius Görgen (MapTailor Geospatial Consulting GbR) info@maptailor.net Maintainer: MAPME-Initiative contact@mapme-initiative.org Contact Person: Dr. Johannes Schielein Copyright: MAPME-Initiative License: GPL-3","code":""},{"path":"https://mapme-initiative.github.io/mapme.forest/news/index.html","id":"mapmeforest-10","dir":"Changelog","previous_headings":"","what":"mapme.forest 1.0","title":"mapme.forest 1.0","text":"Added NEWS.md file track changes package. statsGRASS() function now allows users set temp directory via tmpdir (#5). downloadGFW() now downloads Forest greenhouse gas emission layer Harris et al (2021) (see https://data.globalforestwatch.org/datasets/gfw::forest-greenhouse-gas-emissions/) (#6) Functions working new CO2 emission layer now issue warning data used analysis routines adapted. warning now included README issue resolved (#7)","code":""}]
